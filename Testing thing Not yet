local function string_find(s, pattern)
	return string.find(s, pattern, nil, true)
end

local function ArrayToDict(t, hybrid, val, strict)
	local d = {}
	if hybrid then
		for k, v in t do
			if type(k) == "number" then
				d[v] = val or true
			elseif type(v) == "table" then
				d[k] = ArrayToDict(v, hybrid)
			else
				d[k] = v
			end
		end
	else
		for _, k in t do
			if not strict or strict and type(k) == strict then
				d[k] = true
			end
		end
	end
	return d
end

local global_container
do
	local fname = "UniversalMethodFinder"
	local f
	f, global_container = loadstring(game:HttpGet("https://raw.githubusercontent.com/luau/SomeHub/main/" .. fname .. ".luau", true), fname)()
	f({
		base64encode = 'local a={...}local b=a[1]local function c(a,b)return string.find(a,b,nil,true)end;return c(b,"encode")and(c(b,"base64")or c(string.lower(tostring(a[2])),"base64"))',
		gethiddenproperty = 'string.find(...,"get",nil,true) and string.find(...,"h",nil,true) and string.find(...,"prop",nil,true) and string.sub(...,#...) ~= "s"',
		gethui = 'string.find(...,"get",nil,true) and string.find(...,"h",nil,true) and string.find(...,"ui",nil,true)',
		getnilinstances = 'string.find(...,"nil",nil,true) and string.find(...,"get",nil,true) and string.sub(...,#...) == "s"',
		getscriptbytecode = 'string.find(...,"get",nil,true) and string.find(...,"bytecode",nil,true)',
		hash = 'local a={...}local b=a[1]local function c(a,b)return string.find(a,b,nil,true)end;return c(b,"hash")and c(string.lower(tostring(a[2])),"crypt")',
		protectgui = 'string.find(...,"protect",nil,true) and string.find(...,"ui",nil,true) and not string.find(...,"un",nil,true)',
		setthreadidentity = 'string.find(...,"identity",nil,true) and string.find(...,"set",nil,true)',
	}, true, 10)
end

local getId = identifyexecutor or getexecutorname or whatexecutor
local EXEC_NAME = getId and getId() or ""
local getHP = global_container.gethiddenproperty
local af, rf, wf = appendfile, readfile, writefile
local getBytecode = global_container.getscriptbytecode
local b64enc = global_container.base64encode
local sha384

local service = setmetatable({}, {
	__index = function(self, name)
		local ok, res = pcall(Instance.new, name)
		local svc = ok and res or game:GetService(name) or settings():GetService(name) or UserSettings():GetService(name)
		if svc then
			self[name] = svc
		end
		return svc
	end,
})

local getHP_fallback
do
	local ugc
	getHP_fallback = function(inst, prop)
		if not ugc then
			ugc = service.UGCValidationService
		end
		return ugc:GetPropertyValue(inst, prop)
	end
	if getHP then
		local ok, res = pcall(getHP, workspace, "StreamOutBehavior")
		if not ok or res ~= nil and typeof(res) ~= "EnumItem" then
			getHP = nil
		else
			ok, res = pcall(getHP, Instance.new("AnimationRigData", Instance.new("Folder")), "parent")
			if ok and res ~= nil and type(res) ~= "string" then
				getHP = nil
			end
		end
	end
	local function benchmark(f1, f2, ...)
		local rank = table.create(2)
		for i, f in { f1, f2 } do
			local start = os.clock()
			for _ = 1, 50 do
				f(...)
			end
			rank[i] = { t = os.clock() - start, f = f }
		end
		table.sort(rank, function(a, b)
			return a.t < b.t
		end)
		return rank[1].f
	end
	local tStr = string.rep("\1\0\0\0\1\2\3\4\5\6\7", 50)
	do
		if not bit32.byteswap or not pcall(bit32.byteswap, 1) then
			bit32 = table.clone(bit32)
			local function tobit(num)
				num %= (bit32.bxor(num, 32))
				if 0x80000000 < num then
					num -= bit32.bxor(num, 32)
				end
				return num
			end
			bit32.byteswap = function(num)
				local BYTE_SIZE = 8
				local MAX_BYTE_VALUE = 255
				num %= bit32.bxor(2, 32)
				local a = bit32.band(num, MAX_BYTE_VALUE)
				num = bit32.rshift(num, BYTE_SIZE)
				local b = bit32.band(num, MAX_BYTE_VALUE)
				num = bit32.rshift(num, BYTE_SIZE)
				local c = bit32.band(num, MAX_BYTE_VALUE)
				num = bit32.rshift(num, BYTE_SIZE)
				local d = bit32.band(num, MAX_BYTE_VALUE)
				num = tobit(bit32.lshift(bit32.lshift(bit32.lshift(a, BYTE_SIZE) + b, BYTE_SIZE) + c, BYTE_SIZE) + d)
				return num
			end
			table.freeze(bit32)
		end
		local reselim_b64
		pcall(function()
			local b64_enc_buf = loadstring(game:HttpGet("https://raw.githubusercontent.com/Reselim/Base64/master/Base64.lua", true), "Base64")().encode
			reselim_b64 = function(raw)
				return buffer.tostring(b64_enc_buf(buffer.fromstring(raw)))
			end
		end)
		if b64enc and b64enc("\1\0\0\0\1") == "AQAAAAE=" then
			if reselim_b64 then
				b64enc = benchmark(b64enc, reselim_b64, tStr)
			end
		else
			b64enc = reselim_b64
		end
		assert(b64enc, "base64encode not found")
	end
	do
		local h = global_container.hash
		if h then
			sha384 = function(d)
				return h(d, "sha384")
			end
		end
		local fname = "RequireOnlineModule"
		local hashlib_s384
		pcall(function()
			hashlib_s384 = loadstring(game:HttpGet("https://raw.githubusercontent.com/luau/SomeHub/main/" .. fname .. ".luau", true), fname)()(4544052033).sha384
		end)
		if hashlib_s384 then
			if sha384 then
				sha384 = benchmark(sha384, hashlib_s384, tStr)
			else
				sha384 = hashlib_s384
			end
		end
		assert(sha384, "sha384 hash function not found")
	end
end

local sharedStrs = {}
local sharedStrIds = setmetatable({
	identifier = 1e15,
}, {
	__index = function(self, s)
		local id = b64enc(tostring(self.identifier))
		self.identifier += 1
		self[s] = id
		return id
	end,
})
local inhProps = {}
local defInsts = {}
local referents, ref_size = {}, 0
local function __BIT(...)
	local val = 0
	for i, bit in { ... } do
		if bit then
			val += 2 ^ (i - 1)
		end
	end
	return val
end
local function GetRef(inst)
	local ref = referents[inst]
	if not ref then
		ref = ref_size
		referents[inst] = ref
		ref_size += 1
	end
	return ref
end
local function index(t, k)
	return t[k]
end
local CLIENT_VERSION = tonumber(string.split(version(), ".")[2])
local attr_Type_IDs = {
	string = 0x02,
	boolean = 0x03,
	number = 0x06,
	UDim = 0x09,
	UDim2 = 0x0A,
	Ray = 0x0B,
	Faces = 0x0C,
	Axes = 0x0D,
	BrickColor = 0x0E,
	Color3 = 0x0F,
	Vector2 = 0x10,
	Vector3 = 0x11,
	Vector2int16 = 0x12,
	Vector3int16 = 0x13,
	CFrame = 0x14,
	EnumItem = 0x15,
	NumberSequence = 0x17,
	NumberSequenceKeypoint = 0x18,
	ColorSequence = 0x19,
	ColorSequenceKeypoint = 0x1A,
	NumberRange = 0x1B,
	Rect = 0x1C,
	PhysicalProperties = 0x1D,
	Region3 = 0x1F,
	Region3int16 = 0x20,
	Font = 0x21,
}
local CFrame_Rotation_IDs = {
	["\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63"] = 0x02,
	["\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\63\0\0\0\0"] = 0x03,
	["\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191"] = 0x05,
	["\0\0\128\63\0\0\0\0\0\0\0\128\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\191\0\0\0\0"] = 0x06,
	["\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191"] = 0x07,
	["\0\0\0\0\0\0\0\0\0\0\128\63\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0"] = 0x09,
	["\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\128\0\0\0\0\0\0\0\0\0\0\128\63"] = 0x0a,
	["\0\0\0\0\0\0\0\0\0\0\128\191\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0"] = 0x0c,
	["\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\128\63\0\0\0\0\0\0\0\0"] = 0x0d,
	["\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0"] = 0x0e,
	["\0\0\0\0\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\128\63\0\0\0\0\0\0\0\0"] = 0x10,
	["\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\128"] = 0x11,
	["\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191"] = 0x14,
	["\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\63\0\0\0\128"] = 0x15,
	["\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63"] = 0x17,
	["\0\0\128\191\0\0\0\0\0\0\0\128\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\191\0\0\0\128"] = 0x18,
	["\0\0\0\0\0\0\128\63\0\0\0\128\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63"] = 0x19,
	["\0\0\0\0\0\0\0\0\0\0\128\191\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0"] = 0x1b,
	["\0\0\0\0\0\0\128\191\0\0\0\128\0\0\128\191\0\0\0\0\0\0\0\128\0\0\0\0\0\0\0\0\0\0\128\191"] = 0x1c,
	["\0\0\0\0\0\0\0\0\0\0\128\63\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0"] = 0x1e,
	["\0\0\0\0\0\0\128\63\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\191\0\0\128\191\0\0\0\0\0\0\0\0"] = 0x1f,
	["\0\0\0\0\0\0\0\0\0\0\128\63\0\0\0\0\0\0\128\63\0\0\0\128\0\0\128\191\0\0\0\0\0\0\0\0"] = 0x20,
	["\0\0\0\0\0\0\128\191\0\0\0\0\0\0\0\0\0\0\0\0\0\0\128\63\0\0\128\191\0\0\0\0\0\0\0\0"] = 0x22,
	["\0\0\0\0\0\0\0\0\0\0\128\191\0\0\0\0\0\0\128\191\0\0\0\128\0\0\128\191\0\0\0\0\0\0\0\128"] = 0x23,
}
local Binary_Descriptors
Binary_Descriptors = {
	__SEQUENCE = function(v, fmt, kpSize, Envelope)
		local kps = v.Keypoints
		local kps_n = #kps
		local len = 4 + (kpSize or 12) * kps_n
		local b = buffer.create(len)
		local offset = 0
		buffer.writeu32(b, offset, kps_n)
		offset += 4
		for _, kp in kps do
			buffer.writef32(b, offset, Envelope or kp.Envelope)
			offset += 4
			buffer.writef32(b, offset, kp.Time)
			offset += 4
			local val = kp.Value
			if fmt then
				offset += fmt(val, b, offset)
			else
				buffer.writef32(b, offset, val)
				offset += 4
			end
		end
		return b, len
	end,
	["string"] = function(v)
		local v_len = #v
		local len = 4 + v_len
		local b = buffer.create(len)
		buffer.writeu32(b, 0, v_len)
		buffer.writestring(b, 4, v)
		return b, len
	end,
	["boolean"] = function(v)
		local b = buffer.create(1)
		buffer.writeu8(b, 0, v and 1 or 0)
		return b, 1
	end,
	["number"] = function(v)
		local b = buffer.create(8)
		buffer.writef64(b, 0, v)
		return b, 8
	end,
	["UDim"] = function(v)
		local b = buffer.create(8)
		buffer.writef32(b, 0, v.Scale)
		buffer.writei32(b, 4, v.Offset)
		return b, 8
	end,
	["UDim2"] = function(v)
		local b = buffer.create(16)
		local udimDesc = Binary_Descriptors.UDim
		local X = udimDesc(v.X)
		buffer.copy(b, 0, X)
		local Y = udimDesc(v.Y)
		buffer.copy(b, 8, Y)
		return b, 16
	end,
	["Ray"] = function(v)
		local b = buffer.create(24)
		local v3Desc = Binary_Descriptors.Vector3
		local Origin = v3Desc(v.Origin)
		buffer.copy(b, 0, Origin)
		local Direction = v3Desc(v.Direction)
		buffer.copy(b, 12, Direction)
		return b, 24
	end,
	["Faces"] = function(v)
		local b = buffer.create(4)
		buffer.writeu32(b, 0, __BIT(v.Right, v.Top, v.Back, v.Left, v.Bottom, v.Front))
		return b, 4
	end,
	["Axes"] = function(v)
		local b = buffer.create(4)
		buffer.writeu32(b, 0, __BIT(v.X, v.Y, v.Z))
		return b, 4
	end,
	["BrickColor"] = function(v)
		local b = buffer.create(4)
		buffer.writeu32(b, 0, v.Number)
		return b, 4
	end,
	["Color3"] = function(v)
		local b = buffer.create(12)
		buffer.writef32(b, 0, v.R)
		buffer.writef32(b, 4, v.G)
		buffer.writef32(b, 8, v.B)
		return b, 12
	end,
	["Vector2"] = function(v)
		local b = buffer.create(8)
		buffer.writef32(b, 0, v.X)
		buffer.writef32(b, 4, v.Y)
		return b, 8
	end,
	["Vector3"] = function(v)
		local b = buffer.create(12)
		buffer.writef32(b, 0, v.X)
		buffer.writef32(b, 4, v.Y)
		buffer.writef32(b, 8, v.Z)
		return b, 12
	end,
	["Vector2int16"] = function(v)
		local b = buffer.create(4)
		buffer.writei16(b, 0, v.X)
		buffer.writei16(b, 2, v.Y)
		return b, 4
	end,
	["Vector3int16"] = function(v)
		local b = buffer.create(6)
		buffer.writei16(b, 0, v.X)
		buffer.writei16(b, 2, v.Y)
		buffer.writei16(b, 4, v.Z)
		return b, 6
	end,
	["CFrame"] = function(v)
		local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = v:GetComponents()
		local rotId = CFrame_Rotation_IDs[string.pack("<fffffffff", R00, R01, R02, R10, R11, R12, R20, R21, R22)]
		local len = rotId and 13 or 49
		local b = buffer.create(len)
		buffer.writef32(b, 0, X)
		buffer.writef32(b, 4, Y)
		buffer.writef32(b, 8, Z)
		if rotId then
			buffer.writeu8(b, 12, rotId)
		else
			buffer.writeu8(b, 12, 0x0)
			buffer.writef32(b, 13, R00)
			buffer.writef32(b, 17, R01)
			buffer.writef32(b, 21, R02)
			buffer.writef32(b, 25, R10)
			buffer.writef32(b, 29, R11)
			buffer.writef32(b, 33, R12)
			buffer.writef32(b, 37, R20)
			buffer.writef32(b, 41, R21)
			buffer.writef32(b, 45, R22)
		end
		return b, len
	end,
	["EnumItem"] = function(v)
		local bName, nameSize = Binary_Descriptors.string(tostring(v.EnumType))
		local len = nameSize + 4
		local b = buffer.create(len)
		buffer.copy(b, 0, bName)
		buffer.writeu32(b, nameSize, v.Value)
		return b, len
	end,
	["NumberSequence"] = nil,
	["ColorSequence"] = function(v)
		return Binary_Descriptors.__SEQUENCE(v, function(c3, b, offset)
			buffer.copy(b, offset, Binary_Descriptors.Color3(c3))
			return 12
		end, 20, 0)
	end,
	["NumberRange"] = function(v)
		local b = buffer.create(8)
		buffer.writef32(b, 0, v.Min)
		buffer.writef32(b, 4, v.Max)
		return b, 8
	end,
	["Rect"] = function(v)
		local b = buffer.create(16)
		local Vector2__descriptor = Binary_Descriptors.Vector2
		local Min = Vector2__descriptor(v.Min)
		buffer.copy(b, 0, Min)
		local Max = Vector2__descriptor(v.Max)
		buffer.copy(b, 8, Max)
		return b, 16
	end,
	["PhysicalProperties"] = function(v)
		local len = 1
		if v then
			len += 20
		end
		local b = buffer.create(len)
		buffer.writeu8(b, 0, v and 1 or 0)
		if v then
			buffer.writef32(b, 1, v.Density)
			buffer.writef32(b, 5, v.Friction)
			buffer.writef32(b, 9, v.Elasticity)
			buffer.writef32(b, 13, v.FrictionWeight)
			buffer.writef32(b, 17, v.ElasticityWeight)
		end
		return b, len
	end,
	["Region3"] = function(v)
		local b = buffer.create(24)
		local v3Desc = Binary_Descriptors.Vector3
		local Min = v3Desc(v.Min)
		buffer.copy(b, 0, Min)
		local Max = v3Desc(v.Max)
		buffer.copy(b, 12, Max)
		return b, 24
	end,
	["Region3int16"] = function(v)
		local b = buffer.create(12)
		local Vector3int16__descriptor = Binary_Descriptors.Vector3int16
		local Min = Vector3int16__descriptor(v.Min)
		buffer.copy(b, 0, Min)
		local Max = Vector3int16__descriptor(v.Max)
		buffer.copy(b, 6, Max)
		return b, 12
	end,
	["Font"] = 636 < CLIENT_VERSION and function(v)
		local strDesc = Binary_Descriptors.string
		local bFamily, famSize = strDesc(v.Family)
		local bFaceId, faceIdSize = strDesc("")
		local len = 3 + famSize + faceIdSize
		local b = buffer.create(len)
		local okW, w = pcall(index, v, "Weight")
		local okS, s = pcall(index, v, "Style")
		buffer.writeu16(b, 0, okW and w.Value or 0)
		buffer.writeu8(b, 2, okS and s.Value or 0)
		buffer.copy(b, 3, bFamily)
		buffer.copy(b, 3 + famSize, bFaceId)
		return b, len
	end or function(v)
		local strDesc = Binary_Descriptors.string
		local bFamily, famSize = strDesc(v.Family)
		local bFaceId, faceIdSize = strDesc("")
		local len = 3 + famSize + faceIdSize
		local b = buffer.create(len)
		local fontStr = tostring(v)
		local emptyW = string_find(fontStr, "Weight = ,")
		local emptyS = string_find(fontStr, "Style =  }")
		buffer.writeu16(b, 0, emptyW and 0 or v.Weight.Value)
		buffer.writeu8(b, 2, emptyS and 0 or v.Style.Value)
		buffer.copy(b, 3, bFamily)
		buffer.copy(b, 3 + famSize, bFaceId)
		return b, len
	end,
}
do
	Binary_Descriptors.NumberSequence = Binary_Descriptors.__SEQUENCE
end
local ESCAPES_PATTERN = "[&<>\"'\0\1-\9\11-\12\14-\31\127-\255]"
local ESCAPES = {
	["&"] = "&amp;",
	["<"] = "&lt;",
	[">"] = "&gt;",
	['"'] = "&#34;",
	["'"] = "&#39;",
	["\0"] = "",
}
for rangeStart, rangeEnd in string.gmatch(ESCAPES_PATTERN, "(.)%-(.)") do
	for charCode = string.byte(rangeStart), string.byte(rangeEnd) do
		ESCAPES[string.char(charCode)] = "&#" .. charCode .. ";"
	end
end
local XML_Descriptors
XML_Descriptors = {
	__CDATA = function(v)
		return "<![CDATA[" .. v .. "]]>"
	end,
	__ENUM = function(v)
		return v.Value, "token"
	end,
	__NORMALIZE_NUMBER = function(v)
		if v ~= v then
			return "NAN"
		elseif v == math.huge then
			return "INF"
		elseif v == -math.huge then
			return "-INF"
		end
		return v
	end,
	__NORMALIZE_RANGE = function(v)
		return v ~= v and "0" or v
	end,
	__MINMAX = function(min, max, desc)
		return "<min>" .. desc(min) .. "</min><max>" .. desc(max) .. "</max>"
	end,
	__PROTECTEDSTRING = function(v)
		return string_find(v, "]]>") and string.gsub(v, ESCAPES_PATTERN, ESCAPES) or XML_Descriptors.__CDATA(v)
	end,
	__SEQUENCE = function(v, fmt)
		local normRange = XML_Descriptors.__NORMALIZE_RANGE
		local seq = ""
		for _, kp in v.Keypoints do
			local val = kp.Value
			seq ..= kp.Time .. " " .. (fmt and fmt(val) or normRange(val) .. " " .. normRange(kp.Envelope) .. " ")
		end
		return seq
	end,
	__VECTOR = function(X, Y, Z)
		local val = "<X>" .. X .. "</X><Y>" .. Y .. "</Y>"
		if Z then
			val ..= "<Z>" .. Z .. "</Z>"
		end
		return val
	end,
	Axes = function(v)
		return "<axes>" .. __BIT(v.X, v.Y, v.Z) .. "</axes>"
	end,
	BinaryString = function(v)
		return v == "" and "" or b64enc(v)
	end,
	BrickColor = function(v)
		return v.Number
	end,
	CFrame = function(v)
		local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = v:GetComponents()
		return XML_Descriptors.__VECTOR(X, Y, Z) .. "<R00>" .. R00 .. "</R00><R01>" .. R01 .. "</R01><R02>" .. R02 .. "</R02><R10>" .. R10 .. "</R10><R11>" .. R11 .. "</R11><R12>" .. R12 .. "</R12><R20>" .. R20 .. "</R20><R21>" .. R21 .. "</R21><R22>" .. R22 .. "</R22>", "CoordinateFrame"
	end,
	Color3 = function(v)
		return "<R>" .. v.R .. "</R><G>" .. v.G .. "</G><B>" .. v.B .. "</B>"
	end,
	Color3uint8 = function(v)
		return 0xFF000000 + (math.floor(v.R * 255) * 0x10000) + (math.floor(v.G * 255) * 0x100) + math.floor(v.B * 255)
	end,
	ColorSequence = function(v)
		return XML_Descriptors.__SEQUENCE(v, function(c3)
			local normRange = XML_Descriptors.__NORMALIZE_RANGE
			return normRange(c3.R) .. " " .. normRange(c3.G) .. " " .. normRange(c3.B) .. " 0 "
		end)
	end,
	Content = function(v)
		local srcType = v.SourceType
		return srcType == Enum.ContentSourceType.None and "<null></null>" or srcType == Enum.ContentSourceType.Uri and "<uri>" .. XML_Descriptors.string(v.Uri) .. "</uri>" or srcType == Enum.ContentSourceType.Object and "<Ref>" .. GetRef(v.Object) .. "</Ref>"
	end,
	ContentId = function(v)
		return v == "" and "<null></null>" or "<url>" .. XML_Descriptors.string(v) .. "</url>", "Content"
	end,
	CoordinateFrame = function(v)
		return "<CFrame>" .. XML_Descriptors.CFrame(v) .. "</CFrame>"
	end,
	Faces = function(v)
		return "<faces>" .. __BIT(v.Right, v.Top, v.Back, v.Left, v.Bottom, v.Front) .. "</faces>"
	end,
	Font = 636 < CLIENT_VERSION and function(v)
		local okW, w = pcall(index, v, "Weight")
		local okS, s = pcall(index, v, "Style")
		return "<Family>" .. XML_Descriptors.ContentId(v.Family) .. "</Family><Weight>" .. (okW and XML_Descriptors.__ENUM(w) or "") .. "</Weight><Style>" .. (okS and s.Name or "") .. "</Style>"
	end or function(v)
		local fontStr = tostring(v)
		local emptyW = string_find(fontStr, "Weight = ,")
		local emptyS = string_find(fontStr, "Style =  }")
		return "<Family>" .. XML_Descriptors.ContentId(v.Family) .. "</Family><Weight>" .. (emptyW and "" or XML_Descriptors.__ENUM(v.Weight)) .. "</Weight><Style>" .. (emptyS and "" or v.Style.Name) .. "</Style>"
	end,
	NumberRange = function(v)
		local normRange = XML_Descriptors.__NORMALIZE_RANGE
		return normRange(v.Min) .. " " .. normRange(v.Max)
	end,
	NumberSequence = nil,
	PhysicalProperties = function(v)
		local cp = "<CustomPhysics>" .. XML_Descriptors.bool(v and true or false) .. "</CustomPhysics>"
		return v and cp .. "<Density>" .. v.Density .. "</Density><Friction>" .. v.Friction .. "</Friction><Elasticity>" .. v.Elasticity .. "</Elasticity><FrictionWeight>" .. v.FrictionWeight .. "</FrictionWeight><ElasticityWeight>" .. v.ElasticityWeight .. "</ElasticityWeight>" or cp
	end,
	Ray = function(v)
		local vector3 = XML_Descriptors.Vector3
		return "<origin>" .. vector3(v.Origin) .. "</origin><direction>" .. vector3(v.Direction) .. "</direction>"
	end,
	Rect = function(v)
		return XML_Descriptors.__MINMAX(v.Min, v.Max, XML_Descriptors.Vector2), "Rect2D"
	end,
	Region3 = function(v)
		local Translation = v.CFrame.Position
		local HalfSize = v.Size * 0.5
		return XML_Descriptors.__MINMAX(Translation - HalfSize, Translation + HalfSize, XML_Descriptors.Vector3)
	end,
	Region3int16 = function(v)
		return XML_Descriptors.__MINMAX(v.Min, v.Max, XML_Descriptors.Vector3int16)
	end,
	SharedString = function(v)
		v = v == "" and "" or b64enc(v)
		local id = sharedStrIds[v]
		if sharedStrs[id] == nil then
			sharedStrs[id] = v
		end
		return id
	end,
	SecurityCapabilities = nil,
	UDim = function(v)
		return "<S>" .. v.Scale .. "</S><O>" .. v.Offset .. "</O>"
	end,
	UDim2 = function(v)
		local X, Y = v.X, v.Y
		return "<XS>" .. X.Scale .. "</XS><XO>" .. X.Offset .. "</XO><YS>" .. Y.Scale .. "</YS><YO>" .. Y.Offset .. "</YO>"
	end,
	Vector2 = function(v)
		return XML_Descriptors.__VECTOR(v.X, v.Y)
	end,
	Vector2int16 = nil,
	Vector3 = function(v)
		return XML_Descriptors.__VECTOR(v.X, v.Y, v.Z)
	end,
	Vector3int16 = nil,
	bool = function(v)
		return v and "true" or "false"
	end,
	double = nil,
	float = nil,
	int = nil,
	int64 = nil,
	string = function(v)
		return (v == nil or v == "") and "" or string_find(v, "]]>") and string.gsub(v, ESCAPES_PATTERN, ESCAPES) or XML_Descriptors.__CDATA(string.gsub(v, "\0", ""))
	end,
}
do
	local BASE_CAPS
	pcall(function()
		BASE_CAPS = SecurityCapabilities.new()
	end)
	if BASE_CAPS then
		local CAP_BITS = {
			Plugin = 2 ^ 0,
			LocalUser = 2 ^ 1,
			WritePlayer = 2 ^ 2,
			RobloxScript = 2 ^ 3,
			RobloxEngine = 2 ^ 4,
			NotAccessible = 2 ^ 5,
			RunClientScript = 2 ^ 8,
			RunServerScript = 2 ^ 9,
			AccessOutsideWrite = 2 ^ 11,
			Unassigned = 2 ^ 15,
			AssetRequire = 2 ^ 16,
			LoadString = 2 ^ 17,
			ScriptGlobals = 2 ^ 18,
			CreateInstances = 2 ^ 19,
			Basic = 2 ^ 20,
			Audio = 2 ^ 21,
			DataStore = 2 ^ 22,
			Network = 2 ^ 23,
			Physics = 2 ^ 24,
			UI = 2 ^ 25,
			CSG = 2 ^ 26,
			Chat = 2 ^ 27,
			Animation = 2 ^ 28,
			Avatar = 2 ^ 29,
			Input = 2 ^ 30,
			Environment = 2 ^ 31,
			RemoteEvent = 2 ^ 32,
			LegacySound = 2 ^ 33,
			Players = 2 ^ 34,
			CapabilityControl = 2 ^ 35,
			InternalTest = 2 ^ 60,
			PluginOrOpenCloud = 2 ^ 61,
			Assistant = 2 ^ 62,
		}
		XML_Descriptors.SecurityCapabilities = function(v)
			if v == BASE_CAPS then
				return 0
			end
			local res = 0
			for _, flag in string.split(tostring(v), " | ") do
				local bit = CAP_BITS[flag]
				if bit then
					res += bit
				end
			end
			return res
		end
	end
end
for descName, redirName in {
	NumberSequence = "__SEQUENCE",
	Vector2int16 = "Vector2",
	Vector3int16 = "Vector3",
	double = "__NORMALIZE_NUMBER",
	float = "__NORMALIZE_NUMBER",
	int = "__NORMALIZE_NUMBER",
	int64 = "__NORMALIZE_NUMBER",
} do
	XML_Descriptors[descName] = XML_Descriptors[redirName]
end
if CLIENT_VERSION < math.huge then
	XML_Descriptors.Content = XML_Descriptors.ContentId
end
local ClassList
do
	local ClassPropEx = {
		Whitelist = { TriangleMeshPart = ArrayToDict({ "CollisionFidelity" }) },
		Blacklist = {
			LuaSourceContainer = ArrayToDict({ "ScriptGuid" }),
			Instance = ArrayToDict({ "UniqueId", "HistoryId" }),
		},
	}
	local NSFixes = {
		Instance = {
			AttributesSerialize = function(inst)
				local attrs = inst:GetAttributes()
				if not next(attrs) then
					return ""
				end
				local attrs_n = 0
				local buffer_size = 4
				local attrs_sorted = {}
				local attrs_formatted = table.clone(attrs)
				for attr, val in attrs do
					attrs_n += 1
					attrs_sorted[attrs_n] = attr
					local Type = typeof(val)
					local Descriptor = Binary_Descriptors[Type]
					local attr_size
					attrs_formatted[attr], attr_size = Descriptor(val)
					buffer_size += 5 + #attr + attr_size
				end
				table.sort(attrs_sorted)
				local b = buffer.create(buffer_size)
				local offset = 0
				buffer.writeu32(b, offset, attrs_n)
				offset += 4
				local strDesc = Binary_Descriptors.string
				for _, attr in attrs_sorted do
					local b_Name, Name_size = strDesc(attr)
					buffer.copy(b, offset, b_Name)
					offset += Name_size
					buffer.writeu8(b, offset, attr_Type_IDs[typeof(attrs[attr])])
					offset += 1
					local bb = attrs_formatted[attr]
					buffer.copy(b, offset, bb)
					offset += buffer.len(bb)
				end
				return buffer.tostring(b)
			end,
			DefinesCapabilities = "Sandboxed",
			Tags = function(inst)
				local tags = inst:GetTags()
				if #tags == 0 then
					return ""
				end
				return table.concat(tags, "\0")
			end,
		},
		BallSocketConstraint = { MaxFrictionTorqueXml = "MaxFrictionTorque" },
		BasePart = {
			Color3uint8 = "Color",
			MaterialVariantSerialized = "MaterialVariant",
			size = "Size",
		},
		DoubleConstrainedValue = { value = "Value" },
		IntConstrainedValue = { value = "Value" },
		Terrain = {
			AcquisitionMethod = "LastUsedModificationMethod",
			MaterialColors = function(inst)
				local TERRAIN_MATERIAL_COLORS = {
					Enum.Material.Grass,
					Enum.Material.Slate,
					Enum.Material.Concrete,
					Enum.Material.Brick,
					Enum.Material.Sand,
					Enum.Material.WoodPlanks,
					Enum.Material.Rock,
					Enum.Material.Glacier,
					Enum.Material.Snow,
					Enum.Material.Sandstone,
					Enum.Material.Mud,
					Enum.Material.Basalt,
					Enum.Material.Ground,
					Enum.Material.CrackedLava,
					Enum.Material.Asphalt,
					Enum.Material.Cobblestone,
					Enum.Material.Ice,
					Enum.Material.LeafyGrass,
					Enum.Material.Salt,
					Enum.Material.Limestone,
					Enum.Material.Pavement,
				}
				local b = buffer.create(69)
				local offset = 6
				local RGB_components = { "R", "G", "B" }
				for _, material in TERRAIN_MATERIAL_COLORS do
					local color = inst:GetMaterialColor(material)
					for _, component in RGB_components do
						buffer.writeu8(b, offset, math.floor(color[component] * 255))
						offset += 1
					end
				end
				return buffer.tostring(b)
			end,
		},
		TriangleMeshPart = {
			FluidFidelityInternal = "FluidFidelity",
		},
		MeshPart = { InitialSize = "MeshSize" },
		PartOperation = { InitialSize = "MeshSize" },
		Part = { shape = "Shape" },
		TrussPart = { style = "Style" },
		FormFactorPart = {
			formFactorRaw = "FormFactor",
		},
		Fire = { heat_xml = "Heat", size_xml = "Size" },
		Humanoid = { Health_XML = "Health" },
		HumanoidDescription = {
			EmotesDataInternal = function(inst)
				local emotes_data = ""
				for name, ids in inst:GetEmotes() do
					emotes_data ..= name .. "^" .. table.concat(ids, "^") .. "^\\"
				end
				return emotes_data
			end,
			EquippedEmotesDataInternal = function(inst)
				local equipped_emotes_data = ""
				for _, emote in inst:GetEquippedEmotes() do
					equipped_emotes_data ..= emote.Slot .. "^" .. emote.Name .. "\\"
				end
				return equipped_emotes_data
			end,
		},
		LocalizationTable = {
			Contents = function(inst)
				return inst:GetContents()
			end,
		},
		MaterialService = { Use2022MaterialsXml = "Use2022Materials" },
		Model = {
			ScaleFactor = function(inst)
				return inst:GetScale()
			end,
			WorldPivotData = "WorldPivot",
		},
		PackageLink = { PackageIdSerialize = "PackageId", VersionIdSerialize = "VersionNumber" },
		Players = { MaxPlayersInternal = "MaxPlayers", PreferredPlayersInternal = "PreferredPlayers" },
		StarterPlayer = { AvatarJointUpgrade_Serialized = "AvatarJointUpgrade" },
		Smoke = { size_xml = "Size", opacity_xml = "Opacity", riseVelocity_xml = "RiseVelocity" },
		Sound = {
			xmlRead_MaxDistance_3 = "RollOffMaxDistance",
		},
		WeldConstraint = {
			Part0Internal = "Part0",
			Part1Internal = "Part1",
		},
		Workspace = {
			CollisionGroupData = function()
				local collision_groups = game:GetService("PhysicsService"):GetRegisteredCollisionGroups()
				local col_groups_n = #collision_groups
				if col_groups_n == 0 then
					return "\1\0"
				end
				local buffer_size = 2
				for _, group in collision_groups do
					buffer_size += 7 + #group.name
				end
				local b = buffer.create(buffer_size)
				local offset = 0
				buffer.writeu8(b, offset, 1)
				offset += 1
				buffer.writeu8(b, offset, col_groups_n)
				offset += 1
				for i, group in collision_groups do
					local name, id, mask = group.name, i - 1, group.mask
					local name_len = #name
					buffer.writeu8(b, offset, id)
					offset += 1
					buffer.writeu8(b, offset, 4)
					offset += 1
					buffer.writei32(b, offset, mask)
					offset += 4
					buffer.writeu8(b, offset, name_len)
					offset += 1
					buffer.writestring(b, offset, name)
					offset += name_len
				end
				return buffer.tostring(b)
			end,
		},
	}
	local function FetchAPI()
		local apiDump
		local ok, e = pcall(function()
			if EXEC_NAME == "Zenith" or EXEC_NAME == "Velocity" then
				return
			end
			local verStr = tostring(CLIENT_VERSION)
			local ok, res = pcall(rf, verStr)
			if ok and res and res ~= "" and pcall(service.HttpService.JSONDecode, service.HttpService, res) then
				apiDump = res
				return
			end
			local matchVers, matched = {}
			local deplHist = string.split(game:HttpGet("https://setup.rbxcdn.com/DeployHistory.txt", true), "\n")
			for i = #deplHist, 1, -1 do
				local l = deplHist[i]
				local fver = string.match(l, "file version: ([%d, ]+)")
				if fver then
					if string.split(fver, ", ")[2] == verStr then
						matched = true
						local vhash = string.match(l, "(version%-[^%s]+)")
						if vhash then
							matchVers[vhash] = true
						end
					elseif matched then
						break
					end
				end
			end
			for vhash in matchVers do
				ok, res = pcall(game.HttpGet, game, "https://setup.rbxcdn.com/" .. vhash .. "-Full-API-Dump.json", true)
				if ok then
					local ok, res = pcall(service.HttpService.JSONDecode, service.HttpService, res)
					if ok then
						apiDump = service.HttpService:JSONEncode(res.Classes)
						break
					end
				end
			end
			wf(verStr, apiDump)
		end)
		if not ok or not apiDump then
			warn("[DEBUG] Failed to get " .. version() .. " API Dump, trying latest..")
			warn("[DEBUG]", e)
			apiDump = service.HttpService:JSONEncode(service.HttpService:JSONDecode(game:HttpGet("https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/roblox/Mini-API-Dump.json", true)).Classes)
		end
		local clist = {}
		local Whitelist, Blacklist = ClassPropEx.Whitelist, ClassPropEx.Blacklist
		for _, apiClass in service.HttpService:JSONDecode(apiDump) do
			local classProps, propsSize = {}, 1
			local C = {
				Properties = classProps,
				Superclass = apiClass.Superclass,
			}
			local cTags = apiClass.Tags
			local cName = apiClass.Name
			if cTags then
				C.Tags = ArrayToDict(cTags, nil, nil, "string")
			end
			local nsFixClass = NSFixes[cName]
			local cWhitelist, cBlacklist = Whitelist[cName], Blacklist[cName]
			for _, m in apiClass.Members do
				if m.MemberType == "Property" then
					local ser = m.Serialization
					if ser.CanLoad then
						local pName = m.Name
						if (ser.CanSave or cWhitelist and cWhitelist[pName]) and not (cBlacklist and cBlacklist[pName]) then
							local mTags = m.Tags
							local vType = m.ValueType
							local vTypeName = vType.Name
							if 645 <= CLIENT_VERSION and vTypeName == "Content" then
								continue
							end
							local spec, prefDescName
							if mTags then
								for _, tag in mTags do
									if type(tag) == "table" then
										prefDescName = tag.PreferredDescriptorName
										if prefDescName and spec then
											break
										end
									elseif tag == "NotScriptable" then
										spec = true
										if prefDescName then
											break
										end
									end
								end
							end
							local prop = {
								Name = pName,
								Category = vType.Category,
								ValueType = vTypeName,
								Special = spec,
								CanRead = nil,
							}
							if string.sub(vTypeName, 1, 8) == "Optional" then
								prop.Optional = string.sub(vTypeName, 9)
							end
							if nsFixClass then
								local nsFix = nsFixClass[pName]
								if nsFix then
									prop.Fallback = type(nsFix) == "function" and nsFix or prefDescName and function(inst)
										local ok, res = pcall(index, inst, prefDescName)
										if ok then
											return res
										end
										return inst[nsFix]
									end or function(inst)
										return inst[nsFix]
									end
								end
							elseif prefDescName then
								prop.Fallback = function(inst)
									return inst[prefDescName]
								end
							end
							classProps[propsSize] = prop
							propsSize += 1
						end
					end
				end
			end
			clist[cName] = C
		end
		return clist
	end
	local ok, res = pcall(FetchAPI)
	if ok then
		ClassList = res
	else
		warn("Failed to load the API Dump")
		warn(res)
		return
	end
end
local GLOBAL_ENV = getgenv and getgenv() or _G or shared
local function synsaveinstance(opts, opts2)
	if GLOBAL_ENV.USSI then
		return
	end
	GLOBAL_ENV.USSI = true
	do
		local setthreadidentity = global_container.setthreadidentity
		if setthreadidentity then
			pcall(setthreadidentity, 8)
		end
	end
	local currentstr, currentsize, totalsize, chunks = "", 0, 0, table.create(1)
	local sBuf, sBufSize = {}, 1
	local header = '<roblox version="4">'
	local statTxt
	local OPTS = {
		mode = "optimized",
		noscripts = false,
		scriptcache = true,
		timeout = 10,
		__DEBUG_MODE = false,
		Callback = false,
		DecompileJobless = false,
		DecompileIgnore = {
			"TextChatService",
			ModuleScript = nil,
		},
		IgnoreDefaultPlayerScripts = EXEC_NAME ~= "Wave" and true,
		SaveBytecode = false,
		IgnoreProperties = {},
		IgnoreList = { "CoreGui", "CorePackages" },
		ExtraInstances = {},
		NilInstances = false,
		NilInstancesFixes = {},
		SaveCacheInterval = 0x1600 * 10,
		ShowStatus = true,
		SafeMode = false,
		ShutdownWhenDone = false,
		AntiIdle = true,
		Anonymous = false,
		ReadMe = true,
		FilePath = false,
		Object = false,
		IsModel = false,
		IgnoreDefaultProperties = true,
		IgnoreNotArchivable = true,
		IgnorePropertiesOfNotScriptsOnScriptsMode = false,
		IgnoreSpecialProperties = ArrayToDict({ "Fluxus", "Delta", "Solara" })[EXEC_NAME] or false,
		IsolateLocalPlayer = false,
		IsolateLocalPlayerCharacter = false,
		IsolatePlayers = false,
		IsolateStarterPlayer = false,
		RemovePlayerCharacters = true,
		SaveNotCreatable = false,
		NotCreatableFixes = {
			"",
			"AnimationTrack",
			"Player",
			"PlayerGui",
			"PlayerScripts",
			"PlayerMouse",
			"ScreenshotHud",
			"StudioData",
			"TextSource",
			"TouchTransmitter",
		},
		IgnoreSharedStrings = EXEC_NAME ~= "Wave" and true,
		SharedStringOverwrite = false,
		TreatUnionsAsParts = EXEC_NAME == "Solara",
		AlternativeWritefile = not ArrayToDict({ "WRD", "Xeno", "Zorara" })[EXEC_NAME],
		OptionsAliases = {
			DecompileTimeout = "timeout",
			FileName = "FilePath",
			IgnoreArchivable = "IgnoreNotArchivable",
			IgnoreDefaultProps = "IgnoreDefaultProperties",
			SaveNonCreatable = "SaveNotCreatable",
			SavePlayers = "IsolatePlayers",
		},
	}
	local OPTS_lower, opts_valid = {}, {}
	for optName in OPTS do
		local optNameLower = string.lower(optName)
		if OPTS_lower[optNameLower] then
			warn("DUPLICATE OPTION", optName)
		else
			OPTS_lower[optNameLower] = optName
		end
	end
	for optAlias, optName in OPTS.OptionsAliases do
		local optNameLower = string.lower(optAlias)
		if OPTS_lower[optNameLower] then
			warn("DUPLICATE ALIAS", optAlias)
		else
			OPTS_lower[optNameLower] = optName
		end
	end
	do
		local function mkNilFix(name, cname, sep)
			return function(inst, instPropOverrides)
				local exists
				if not sep then
					exists = OPTS.NilInstancesFixes[name]
				end
				local fix
				local noExist = not exists
				if noExist then
					fix = Instance.new(cname)
					if not sep then
						OPTS.NilInstancesFixes[name] = fix
					end
					instPropOverrides[fix] = { __SaveSpecific = true, __Children = { inst }, Properties = { Name = name } }
				else
					fix = exists
					table.insert(instPropOverrides[fix].__Children, inst)
				end
				if noExist then
					return fix
				end
			end
		end
		OPTS.NilInstancesFixes.Animator = mkNilFix("Animator has to be placed under Humanoid or AnimationController", "AnimationController")
		OPTS.NilInstancesFixes.AdPortal = mkNilFix("AdPortal must be parented to a Part", "Part")
		OPTS.NilInstancesFixes.Attachment = mkNilFix("Attachments must be parented to a BasePart or another Attachment", "Part")
		OPTS.NilInstancesFixes.BaseWrap = mkNilFix("BaseWrap must be parented to a MeshPart", "MeshPart")
		OPTS.NilInstancesFixes.PackageLink = mkNilFix("Package already has a PackageLink", "Folder", true)
		if opts2 and type(opts2) == "table" then
			local tmp = opts
			local t = typeof(tmp)
			opts = opts2
			if t == "Instance" then
				opts.Object = tmp
			elseif t == "table" and typeof(tmp[1]) == "Instance" then
				opts.ExtraInstances = tmp
				OPTS.IsModel = true
			end
		end
		local t = typeof(opts)
		if t == "table" then
			if typeof(opts[1]) == "Instance" then
				OPTS.mode = "invalidmode"
				OPTS.ExtraInstances = opts
				OPTS.IsModel = true
				opts = {}
			else
				for k, v in opts do
					local opt = OPTS_lower[string.lower(k)]
					if opt then
						OPTS[opt] = v
						opts_valid[opt] = true
					end
				end
				local dec = opts.Decompile
				if dec ~= nil then
					OPTS.noscripts = not dec
				end
				local saveChars = opts.SavePlayerCharacters
				if saveChars ~= nil then
					OPTS.RemovePlayerCharacters = not saveChars
				end
				local remPlrs = opts.RemovePlayers
				if remPlrs ~= nil then
					OPTS.IsolatePlayers = not remPlrs
				end
			end
		elseif t == "Instance" then
			OPTS.mode = "invalidmode"
			OPTS.Object = opts
			opts = {}
		else
			opts = {}
		end
	end
	if OPTS.IgnoreDefaultPlayerScripts then
		local decIgnore = OPTS.DecompileIgnore
		local Path = service.StarterPlayer:FindFirstChild("StarterPlayerScripts")
		local Exclude = { ModuleScript = { "PlayerModule" }, LocalScript = { "RbxCharacterSounds" } }
		if Path then
			for _, className in Exclude do
				for _, name in className do
					local Found = Path:FindFirstChild(name)
					if Found then
						table.insert(decIgnore, Found)
					end
				end
			end
		end
	end
	local instOverrides = {}
	local decIgnore, ignList, ignProps, ncFixes = ArrayToDict(OPTS.DecompileIgnore, true), ArrayToDict(OPTS.IgnoreList, true), ArrayToDict(OPTS.IgnoreProperties), ArrayToDict(OPTS.NotCreatableFixes, true, "Folder")
	local DEBUG = OPTS.__DEBUG_MODE
	if DEBUG and type(DEBUG) ~= "function" then
		DEBUG = warn
	end
	local fpath = OPTS.FilePath
	local cacheInterval = OPTS.SaveCacheInterval
	local saveInst = OPTS.Object
	local isModel = OPTS.IsModel
	if saveInst and opts.IsModel == nil then
		isModel = true
	end
	local ignDefProps = OPTS.IgnoreDefaultProperties
	local ignNotArch = not OPTS.IgnoreNotArchivable
	local ignPropsNotScript = OPTS.IgnorePropertiesOfNotScriptsOnScriptsMode
	local oldGetHP
	if OPTS and getHP then
		oldGetHP = getHP
		getHP = nil
	end
	local saveNC = OPTS.SaveNotCreatable
	local unionsAsParts = OPTS.TreatUnionsAsParts
	local decJobless = OPTS.DecompileJobless
	if decJobless then
		OPTS.scriptcache = true
	end
	local scrCache = OPTS.scriptcache and getBytecode
	local timeout = OPTS.timeout
	local ignSharedStrs = OPTS.IgnoreSharedStrings
	local sharedStrOvr = OPTS.SharedStringOverwrite
	local decCache = GLOBAL_ENV.scriptcache
	local decIgnoring, saveList, decompileLua, fname, t_start, saveNCEnabled, recScripts
	if OPTS.ReadMe then
		recScripts = {}
	end
	if scrCache and not decCache then
		decCache = {}
		GLOBAL_ENV.scriptcache = decCache
	end
	if saveInst == game then
		OPTS.mode = "full"
		saveInst = nil
		isModel = nil
	end
	local function isLuaSourceContainer(inst)
		return inst:IsA("LuaSourceContainer")
	end
	do
		local mode = string.lower(OPTS.mode)
		local tmp = table.clone(OPTS.ExtraInstances)
		local pname = game.PlaceId
		pcall(function()
			pname ..= " " .. service.MarketplaceService:GetProductInfo(pname).Name
		end)
		local function saneFName(s)
			return string.sub(string.gsub(string.gsub(string.gsub(s, "[^%w _]", ""), " +", " "), " +$", ""), 1, 240)
		end
		if saveInst then
			if mode == "optimized" then
				mode = "full"
			end
			for _, k in {
				"IsolateLocalPlayer",
				"IsolateLocalPlayerCharacter",
				"IsolatePlayers",
				"IsolateStarterPlayer",
				"NilInstances",
			} do
				if opts_valid[k] == nil then
					OPTS[k] = false
				end
			end
		end
		if isModel then
			fname = (fpath or saneFName("model " .. pname .. " " .. (saveInst or tmp[1] or game):GetFullName())) .. ".rbxmx"
		else
			fname = (fpath or saneFName("place " .. pname)) .. ".rbxlx"
		end
		if GLOBAL_ENV[fname] then
			return
		end
		GLOBAL_ENV[fname] = true
		GLOBAL_ENV.USSI = nil
		if mode ~= "scripts" then
			ignPropsNotScript = nil
		end
		local root = saveInst or game
		if mode == "full" then
			if not saveInst then
				local children = root:GetChildren()
				if 0 < #children then
					local tmpDict = ArrayToDict(tmp)
					for _, c in children do
						if not tmpDict[c] then
							table.insert(tmp, c)
						end
					end
				end
			end
		elseif mode == "optimized" then
			local tmpDict = ArrayToDict(tmp)
			for _, svcName in {
				"Workspace",
				"Players",
				"Lighting",
				"MaterialService",
				"ReplicatedFirst",
				"ReplicatedStorage",
				"ServerScriptService",
				"ServerStorage",
				"StarterGui",
				"StarterPack",
				"StarterPlayer",
				"Teams",
				"SoundService",
				"Chat",
				"TextChatService",
				"LocalizationService",
				"JointsService",
			} do
				local svc = game:FindService(svcName)
				if svc and not tmpDict[svc] then
					table.insert(tmp, svc)
				end
			end
		elseif mode == "scripts" then
			local unique = {}
			for _, inst in root:GetDescendants() do
				if isLuaSourceContainer(inst) then
					local p = inst.Parent
					while p and p ~= root do
						inst = inst.Parent
						p = inst.Parent
					end
					if p then
						unique[inst] = true
					end
				end
			end
			for inst in unique do
				table.insert(tmp, inst)
			end
		end
		saveList = tmp
		if saveInst then
			table.insert(saveList, 1, saveInst)
		end
	end
	local isoLP = OPTS.IsolateLocalPlayer
	local isoLPC = OPTS.IsolateLocalPlayerCharacter
	local isoP = OPTS.IsolatePlayers
	local isoSP = OPTS.IsolateStarterPlayer
	local nilInsts = OPTS.NilInstances
	if nilInsts and enablenilinstances then
		enablenilinstances()
	end
	local function get_size_format()
		local Size
		for i, unit in {
			"B",
			"KB",
			"MB",
			"GB",
			"TB",
		} do
			if totalsize < 0x400 ^ i then
				Size = math.floor(totalsize / (0x400 ^ (i - 1)) * 10) / 10 .. " " .. unit
				break
			end
		end
		return Size
	end
	local RunService = service.RunService
	local function wait_for_render()
		RunService.RenderStepped:Wait()
	end
	local Loading
	local function run_with_loading(txt, keep, wait, taskFn, ...)
		local prevStat
		if statTxt then
			if keep then
				prevStat = statTxt.Text
			end
			Loading = task.spawn(function()
				local spin_i = 0
				local spinChars = { "|", "/", "â€”", "\\" }
				local spinLen = #spinChars
				local function getLoadingText()
					spin_i += 1
					if spinLen < spin_i then
						spin_i = 1
					end
					return spinChars[spin_i]
				end
				txt ..= " "
				while true do
					statTxt.Text = txt .. getLoadingText()
					task.wait(0.25)
				end
			end)
			if wait then
				wait_for_render()
			end
		end
		local res = { taskFn(...) }
		if Loading then
			task.cancel(Loading)
			Loading = nil
			if prevStat then
				statTxt.Text = prevStat
			end
		end
		return unpack(res)
	end
	local function construct_TimeoutHandler(t, fn, t_ret)
		return t < 0 and function(scr)
			return pcall(fn, scr)
		end or function(scr)
			local thr = coroutine.running()
			local tThr, cancelled
			tThr = task.delay(t, function()
				cancelled = true
				coroutine.resume(thr, nil, t_ret)
			end)
			task.spawn(function()
				local ok, res = pcall(fn, scr)
				if cancelled then
					return
				end
				task.cancel(tThr)
				while coroutine.status(thr) ~= "suspended" do
					task.wait()
				end
				coroutine.resume(thr, ok, res)
			end)
			return coroutine.yield()
		end
	end
	local getbytecode
	if getBytecode then
		getbytecode = construct_TimeoutHandler(3, getBytecode)
	end
	local SaveBytecode
	if OPTS.SaveBytecode and getBytecode then
		SaveBytecode = function(scr)
			local ok, bc = getbytecode(scr)
			if ok and bc and bc ~= "" then
				return "-- Bytecode (Base64):\n-- " .. b64enc(bc) .. "\n\n"
			end
		end
	end
	do
		local Decomp = decompile
		if OPTS.noscripts then
			decompileLua = function()
				return "-- Decompiling is disabled"
			end
		elseif Decomp then
			local dec = construct_TimeoutHandler(timeout, Decomp, "Decompiler timed out")
			decompileLua = function(scr)
				local hash_bc
				if scrCache then
					local ok, bc = getbytecode(scr)
					local cached
					if ok then
						if not bc or bc == "" then
							return "-- The Script is Empty"
						end
						hash_bc = sha384(bc)
						cached = decCache[hash_bc]
					end
					if cached then
						if DEBUG then
							DEBUG("Found in Cache", scr:GetFullName())
						end
						return cached
					end
				else
					if decJobless then
						return "-- Not found in already decompiled ScriptCache"
					end
					task.wait()
				end
				local ok, res = run_with_loading("Decompiling " .. scr.Name, true, nil, dec, scr)
				if not res then
					ok, res = false, "Empty Output"
				end
				local out
				if ok then
					res = string.gsub(res, "\0", "\\0")
					out = res
				else
					out = "--[[ Failed to decompile. Reason:\n" .. (res or "") .. "\n]]"
				end
				if scrCache and hash_bc then
					decCache[hash_bc] = out
					if DEBUG then
						DEBUG("Cached", scr:GetFullName())
					end
				end
				return out
			end
		else
			decompileLua = function()
				return "-- Your Executor does NOT have a Decompiler"
			end
		end
	end
	local function GetLocalPlayer()
		return service.Players.LocalPlayer or service.Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or service.Players.LocalPlayer
	end
	local function filterLinkedSource(s)
		local ok, res = pcall(service.HttpService.JSONDecode, service.HttpService, s)
		if ok and res.errors then
			return
		end
		return true
	end
	local function replaceClassName(inst, instName, cname)
		local instOvr
		if instName ~= cname then
			instOvr = instOverrides[inst]
			if not instOvr then
				instOvr = { Properties = { Name = "[" .. cname .. "] " .. instName } }
				instOverrides[inst] = instOvr
			end
		end
		return instOvr
	end
	local function filterPropVal(res, pname, cat)
		return res == nil or res == "can't get value" or type(res) == "string" and (cat == "Enum" or string_find(res, "Unable to get property " .. pname))
	end
	local __BREAK = "__BREAK" .. service.HttpService:GenerateGUID(false)
	local function ReadProperty(inst, prop, pname, spec, cat, opt)
		local raw = __BREAK
		local instOvr = instOverrides[inst]
		if instOvr then
			local propsOvr = instOvr.Properties
			if propsOvr then
				local pOvr = propsOvr[pname]
				if pOvr ~= nil then
					return pOvr
				end
			end
		end
		local canRead = prop.CanRead
		if canRead == false then
			return __BREAK
		end
		if spec then
			if getHP then
				local ok, res = pcall(getHP, inst, pname)
				if ok then
					raw = res
				end
				if filterPropVal(raw, pname, cat) then
					if res ~= nil or not opt then
						if DEBUG then
							DEBUG("Filtered", pname)
						end
						prop.CanRead = false
					end
					return __BREAK
				end
			end
		else
			if canRead then
				raw = inst[pname]
			else
				local ok, res = pcall(index, inst, pname)
				if ok then
					raw = res
				elseif getHP then
					ok, res = pcall(getHP, inst, pname)
					if ok then
						raw = res
						prop.Special = true
					end
				end
				prop.CanRead = ok
				if not ok or filterPropVal(raw, pname, cat) then
					return __BREAK
				end
			end
		end
		return raw
	end
	local function ReturnItem(cname, inst)
		return '<Item class="' .. cname .. '" referent="' .. GetRef(inst) .. '"><Properties>'
	end
	local function ReturnProperty(tag, pname, val)
		return "<" .. tag .. ' name="' .. pname .. '">' .. val .. "</" .. tag .. ">"
	end
	local function ReturnValueAndTag(v, vtype, desc)
		local value, tag = (desc or XML_Descriptors[vtype])(v)
		return value, tag or vtype
	end
	local function InheritsFix(fixes, cname, inst)
		local fix = fixes[cname]
		if fix then
			return fix
		elseif fix == nil then
			for c_name, f in fixes do
				if inst:IsA(c_name) then
					return f
				end
			end
		end
	end
	local function GetInheritedProps(cname)
		local props = {}
		local layer = ClassList[cname]
		while layer do
			local lprops = layer.Properties
			table.move(lprops, 1, #lprops, #props + 1, props)
			layer = ClassList[layer.Superclass]
		end
		inhProps[cname] = props
		return props
	end
	local CHUNK_LIMIT = 200 * 1024 * 1024
	local function save_cache(final)
		local s = table.concat(sBuf)
		currentstr ..= s
		local s_len = #s
		totalsize += s_len
		currentsize += s_len
		table.clear(sBuf)
		sBufSize = 1
		if CHUNK_LIMIT < currentsize or final then
			table.insert(chunks, { size = currentsize, str = currentstr })
			currentstr, currentsize = "", 0
		end
		if statTxt then
			statTxt.Text = "Saving.. Size: " .. get_size_format()
		end
		wait_for_render()
	end
	local function save_specific(cname, props)
		local ref = Instance.new(cname)
		local item = ReturnItem(ref.ClassName, ref)
		for pname, v in props do
			local wlisted, val, tag
			if "Source" == pname then
				tag = "ProtectedString"
				val = XML_Descriptors.__PROTECTEDSTRING(v)
				wlisted = true
			elseif "Name" == pname then
				wlisted = true
				val, tag = ReturnValueAndTag(v, "string")
			end
			if wlisted then
				item ..= ReturnProperty(tag, pname, val)
			end
		end
		item ..= "</Properties>"
		return item
	end
	local function save_hierarchy(hier)
		for _, inst in hier do
			if ignNotArch and not inst.Archivable then
				continue
			end
			local skip = ignList[inst]
			if skip then
				continue
			end
			local cname = inst.ClassName
			local instName = inst.Name
			do
				local onIgn = ignList[cname]
				if onIgn and (onIgn == true or onIgn[instName]) then
					continue
				end
			end
			if not decIgnoring then
				decIgnoring = decIgnore[inst]
				if decIgnoring == nil then
					local decIgnored = decIgnore[cname]
					if decIgnored then
						decIgnoring = decIgnored == true or decIgnored[instName]
					end
				end
				if decIgnoring then
					decIgnoring = inst
				elseif decIgnoring == false then
					decIgnoring = 1
				end
			end
			local instOvr, cnameOvr, ctagOvr
			do
				local fix = ncFixes[cname]
				if fix then
					if saveNC then
						cname, instOvr = fix, replaceClassName(inst, instName, cname)
					else
						continue
					end
				else
					if unionsAsParts and inst:IsA("PartOperation") then
						cname, instOvr = "Part", replaceClassName(inst, instName, cname)
						cnameOvr = "BasePart"
					elseif not ClassList[cname] then
						if DEBUG then
							DEBUG("Class not Found", cname)
						end
						ctagOvr = cname
						cname = "Folder"
					end
				end
			end
			if not instOvr then
				instOvr = instOverrides[inst]
			end
			if instOvr and instOvr.__SaveSpecific then
				sBuf[sBufSize] = save_specific(cname, instOvr.Properties)
				sBufSize += 1
			else
				sBuf[sBufSize] = ReturnItem(ctagOvr or cname, inst)
				sBufSize += 1
				if not (ignPropsNotScript and not isLuaSourceContainer(inst)) then
					local defInst, newDefInst
					if ignDefProps then
						defInst = defInsts[cname]
						if not defInst then
							local cTags = ClassList[cname].Tags
							if not (cTags and cTags.NotCreatable) then
								newDefInst = Instance.new(cname)
								defInst = {}
								defInsts[cname] = defInst
							elseif DEBUG then
								DEBUG("Unable to create default Instance", cname)
							end
						end
					end
					local props
					do
						local cls = cnameOvr or cname
						props = inhProps[cls]
						if not props then
							props = GetInheritedProps(cls)
							inhProps[cls] = props
						end
					end
					for _, prop in props do
						local pname = prop.Name
						if ignProps[pname] then
							continue
						end
						local vtype = prop.ValueType
						if ignSharedStrs and vtype == "SharedString" then
							continue
						end
						local spec, cat, opt = prop.Special, prop.Category, prop.Optional
						local raw = ReadProperty(inst, prop, pname, spec, cat, opt)
						if raw == __BREAK then
							local ok, res = pcall(getHP_fallback, inst, pname)
							if res == nil and not opt then
								ok = nil
							end
							if ok then
								raw = res
							else
								local fallback = prop.Fallback
								if fallback then
									ok, res = pcall(fallback, inst)
									if ok then
										raw = res
									else
										if DEBUG then
											DEBUG("Fix Failed", pname)
										end
										continue
									end
								else
									continue
								end
							end
						end
						if sharedStrOvr and vtype == "BinaryString" then
							vtype = "SharedString"
						end
						if defInst and not prop.Special and not (pname == "Source" and isLuaSourceContainer(inst)) then
							if newDefInst then
								defInst[pname] = index(newDefInst, pname)
							end
							if defInst[pname] == raw then
								continue
							end
						end
						local tag, val
						if cat == "Class" then
							tag = "Ref"
							if raw then
								if saveNCEnabled then
									local fix = ncFixes[raw.ClassName]
									if fix and (pname == "PlayerToHideFrom" or vtype ~= "Instance" and vtype ~= fix) then
										continue
									end
								end
								val = GetRef(raw)
							else
								val = "null"
							end
						elseif cat == "Enum" then
							val, tag = XML_Descriptors.__ENUM(raw)
						else
							local desc = XML_Descriptors[vtype]
							if desc then
								val, tag = ReturnValueAndTag(raw, vtype, desc)
							elseif "ProtectedString" == vtype then
								tag = vtype
								if pname == "Source" then
									if decIgnoring then
										if decIgnoring == 1 then
											decIgnoring = nil
										end
										val = "-- Ignored"
									else
										local shouldDec = true
										local linkSrc
										local linkSrcURL = inst.LinkedSource
										local hasLinkSrc = linkSrcURL ~= ""
										local linkSrcType
										if hasLinkSrc then
											local path = inst:GetFullName()
											if recScripts then
												table.insert(recScripts, path)
											end
											linkSrc = string.match(linkSrcURL, "%w+$")
											if linkSrc then
												if scrCache then
													local cached = decCache[linkSrc]
													if cached then
														val = cached
														shouldDec = nil
													end
												end
												if shouldDec then
													if decJobless then
														val = "-- Not found in LinkedSource ScriptCache"
														shouldDec = nil
													end
													linkSrcType = string.find(linkSrc, "%a") and "hash" or "id"
													local asset = linkSrcType .. "=" .. linkSrc
													local ok, src = pcall(function()
														return game:HttpGet("https://assetdelivery.roproxy.com/v1/asset/?" .. asset)
													end)
													if ok and filterLinkedSource(src) then
														if scrCache then
															decCache[linkSrc] = src
														end
														val = src
														shouldDec = nil
													end
												end
											else
												warn("FAILED TO EXTRACT ORIGINAL SCRIPT SOURCE (OPEN A GITHUB ISSUE): ", inst:GetFullName(), linkSrcURL)
											end
										end
										if shouldDec then
											local isLocal = inst:IsA("LocalScript")
											if isLocal and inst.RunContext == Enum.RunContext.Server or not isLocal and inst:IsA("Script") and inst.RunContext ~= Enum.RunContext.Client then
												val = "-- [FilteringEnabled] Server Scripts are IMPOSSIBLE to save"
											else
												val = decompileLua(inst)
												if SaveBytecode then
													local out = SaveBytecode(inst)
													if out then
														val = out .. val
													end
												end
											end
										end
										val = (hasLinkSrc and "-- Original Source: https://assetdelivery.roblox.com/v1/asset/?" .. (linkSrcType or "id") .. "=" .. (linkSrc or linkSrcURL) .. "\n\n" or "") .. val
									end
								end
								val = XML_Descriptors.__PROTECTEDSTRING(val)
							else
								if opt then
									desc = XML_Descriptors[opt]
									if desc then
										if raw == nil then
											continue
										else
											val, tag = ReturnValueAndTag(raw, vtype, desc)
										end
									end
								end
							end
						end
						if tag then
							sBuf[sBufSize] = ReturnProperty(tag, pname, val)
							sBufSize += 1
						else
							warn("UNSUPPORTED TYPE (OPEN A GITHUB ISSUE): ", vtype, cname, pname)
						end
					end
				end
				sBuf[sBufSize] = "</Properties>"
				sBufSize += 1
				if cacheInterval < sBufSize then
					save_cache()
				end
			end
			if skip ~= false then
				local children = instOvr and instOvr.__Children or inst:GetChildren()
				if #children ~= 0 then
					save_hierarchy(children)
				end
			end
			if decIgnoring and decIgnoring == inst then
				decIgnoring = nil
			end
			sBuf[sBufSize] = "</Item>"
			sBufSize += 1
		end
	end
	local function save_extra(name, hier, cname, src)
		sBuf[sBufSize] = save_specific((cname or "Folder"), { Name = name, Source = src })
		sBufSize += 1
		if hier then
			save_hierarchy(hier)
		end
		sBuf[sBufSize] = "</Item>"
		sBufSize += 1
	end
	local function save_game()
		do
			if isModel then
				header ..= '<Meta name="ExplicitAutoJoints">true</Meta>'
			end
			wf(fname, header)
		end
		saveNCEnabled = saveNC or (isoLP or isoLPC) and isoLP or isoP or nilInsts and global_container.getnilinstances
		save_hierarchy(saveList)
		if isoLP or isoLPC then
			local lp = service.Players.LocalPlayer
			if lp then
				if isoLP then
					saveNC = true
					save_extra("LocalPlayer", lp:GetChildren())
				end
				if isoLPC then
					local lpc = lp.Character
					if lpc then
						save_extra("LocalPlayer Character", lpc:GetChildren())
					end
				end
			end
		end
		if isoSP then
			save_extra("StarterPlayer", service.StarterPlayer:GetChildren())
		end
		if isoP then
			saveNC = true
			save_extra("Players", service.Players:GetChildren())
		end
		if nilInsts and global_container.getnilinstances then
			local nilInsts, nilInstsSize = {}, 1
			local nilFixes = OPTS.NilInstancesFixes
			for _, inst in global_container.getnilinstances() do
				if inst == game then
					inst = nil
				else
					local cname = inst.ClassName
					local fix = InheritsFix(nilFixes, cname, inst)
					if fix then
						inst = fix(inst, instOverrides)
					end
					local C = ClassList[cname]
					if C then
						local cTags = C.Tags
						if cTags and cTags.Service then
							inst = nil
						end
					end
				end
				if inst then
					nilInsts[nilInstsSize] = inst
					nilInstsSize += 1
				end
			end
			saveNC = true
			save_extra("Nil Instances", nilInsts)
		end
		if OPTS.ReadMe then
			save_extra("README", nil, "Script", "--[[\n" .. (#recScripts ~= 0 and "IMPORTANT: Original Source of these Scripts was Recovered: " .. service.HttpService:JSONEncode(recScripts) .. "\n" or "") .. "This file was generated with the following settings:\n" .. service.HttpService:JSONEncode(OPTS) .. "\n\nElapsed time: " .. os.clock() - t_start .. " PlaceId: " .. game.PlaceId .. " PlaceVersion: " .. game.PlaceVersion .. " Client Version: " .. version() .. " Executor: " .. (getId and table.concat({ getId() }, " ") or "Unknown") .. "\n]]")
		end
		do
			local t = { "<SharedStrings>" }
			for identifier, value in sharedStrs do
				table.insert(t, '<SharedString md5="' .. identifier .. '">' .. value .. "</SharedString>")
			end
			if 1 < #t then
				sBuf[sBufSize] = table.concat(t)
				sBufSize += 1
				sBuf[sBufSize] = "</SharedStrings>"
				sBufSize += 1
			end
		end
		sBuf[sBufSize] = "</roblox>"
		sBufSize += 1
		save_cache(true)
		do
			if OPTS.Anonymous then
				local lp = service.Players.LocalPlayer
				if lp then
					local function gsubi(input, search, replacement)
						local inputLower = string.lower(input)
						search = string.lower(search)
						local lastFinish = 0
						local subStrings = {}
						local search_len = #search
						local input_len = #input
						while search_len <= input_len - lastFinish do
							local init = lastFinish + 1
							local start, finish = string.find(inputLower, search, init, true)
							if start == nil then
								break
							end
							table.insert(subStrings, string.sub(input, init, start - 1))
							lastFinish = finish
						end
						if lastFinish == 0 then
							return input
						end
						table.insert(subStrings, string.sub(input, lastFinish + 1))
						return table.concat(subStrings, replacement)
					end
					local anon = type(OPTS.Anonymous) == "table" and OPTS.Anonymous or { UserId = "1", Name = "Roblox" }
					for _, c in chunks do
						c.str = gsubi(string.gsub(c.str, lp.UserId, anon.UserId), lp.Name, anon.Name)
					end
				end
			end
			local cb = OPTS.Callback
			if cb then
				local fullStr = header
				for _, c in chunks do
					fullStr ..= c.str
				end
				cb(fullStr, chunks, totalsize)
			elseif OPTS.AlternativeWritefile and af then
				local SEGMENT_SIZE = 4145728
				local totallen, currentlen = math.ceil(totalsize / SEGMENT_SIZE), 1
				for _, c in chunks do
					local length = math.ceil(c.size / SEGMENT_SIZE)
					for i = 1, length do
						local s = string.sub(c.str, (i - 1) * SEGMENT_SIZE + 1, i * SEGMENT_SIZE)
						run_with_loading("Writing to File " .. math.round(currentlen / totallen * 100) .. "% (Depends on Exec)", nil, true, af, fname, s)
						currentlen += 1
						if i ~= length then
							task.wait()
						end
					end
				end
			else
				local fullStr = header
				for _, c in chunks do
					fullStr ..= c.str
				end
				run_with_loading("Writing " .. get_size_format() .. " to File (Depends on Exec)", nil, true, wf, fname, fullStr)
			end
		end
		table.clear(sharedStrs)
	end
	local Connections
	do
		local Players = service.Players
		if ignList.Model ~= true then
			Connections = {}
			local function ignoreCharacter(player)
				table.insert(Connections, player.CharacterAdded:Connect(function(character)
					ignList[character] = true
				end))
				local Character = player.Character
				if Character then
					ignList[Character] = true
				end
			end
			if OPTS.RemovePlayerCharacters then
				table.insert(Connections, Players.PlayerAdded:Connect(function(player)
					ignoreCharacter(player)
				end))
				for _, player in Players:GetPlayers() do
					ignoreCharacter(player)
				end
			else
				ignNotArch = false
				if isoLPC then
					task.spawn(function()
						ignoreCharacter(GetLocalPlayer())
					end)
				end
			end
		end
		if isoLP and ignList.Player ~= true then
			task.spawn(function()
				ignList[GetLocalPlayer()] = true
			end)
		end
	end
	if isoSP then
		ignList.StarterPlayer = false
	end
	if isoP then
		ignList.Players = false
	end
	if OPTS.ShowStatus then
		do
			local Exists = GLOBAL_ENV._statustext
			if Exists then
				Exists:Destroy()
			end
		end
		local StatusGui = Instance.new("ScreenGui")
		GLOBAL_ENV._statustext = StatusGui
		StatusGui.DisplayOrder = 2e9
		pcall(function()
			StatusGui.OnTopOfCoreBlur = true
		end)
		statTxt = Instance.new("TextLabel")
		statTxt.Text = "Saving..."
		statTxt.BackgroundTransparency = 1
		statTxt.Font = Enum.Font.Code
		statTxt.AnchorPoint = Vector2.new(1)
		statTxt.Position = UDim2.new(1)
		statTxt.Size = UDim2.new(0.3, 0, 0, 20)
		statTxt.TextColor3 = Color3.new(1, 1, 1)
		statTxt.TextScaled = true
		statTxt.TextStrokeTransparency = 0.7
		statTxt.TextXAlignment = Enum.TextXAlignment.Right
		statTxt.TextYAlignment = Enum.TextYAlignment.Top
		statTxt.Parent = StatusGui
		local function randomString()
			local length = math.random(10, 20)
			local randomarray = table.create(length)
			for i = 1, length do
				randomarray[i] = string.char(math.random(32, 126))
			end
			return table.concat(randomarray)
		end
		if global_container.gethui then
			StatusGui.Name = randomString()
			StatusGui.Parent = global_container.gethui()
		else
			if global_container.protectgui then
				StatusGui.Name = randomString()
				global_container.protectgui(StatusGui)
				StatusGui.Parent = game:GetService("CoreGui")
			else
				local RobloxGui = game:GetService("CoreGui"):FindFirstChild("RobloxGui")
				if RobloxGui then
					StatusGui.Parent = RobloxGui
				else
					StatusGui.Name = randomString()
					StatusGui.Parent = game:GetService("CoreGui")
				end
			end
		end
	end
	do
		local SafeMode = OPTS.SafeMode
		if SafeMode then
			task.spawn(function()
				local lp = GetLocalPlayer()
				local PlayerScripts = lp:FindFirstChild("PlayerScripts")
				if PlayerScripts then
					local function construct_InstanceOverride(inst)
						local children = inst:GetChildren()
						instOverrides[inst] = {
							__Children = children,
						}
						for _, child in children do
							construct_InstanceOverride(child)
						end
					end
					construct_InstanceOverride(PlayerScripts)
					instOverrides[lp] = {
						__Children = lp:GetChildren(),
						Properties = { Name = "[" .. lp.ClassName .. "] " .. lp.Name },
					}
				end
				lp:Kick("\n[SAFEMODE] Saving in Progress..\nPlease do NOT leave")
				wait_for_render()
				task.delay(10, service.GuiService.ClearError, service.GuiService)
			end)
			service.RunService:Set3dRenderingEnabled(false)
		end
		local anti_idle
		if OPTS.AntiIdle then
			task.spawn(function()
				local Idled = GetLocalPlayer().Idled
				if getconnections then
					for _, c in getconnections(Idled) do
						if not pcall(function()
							c:Disable()
						end) then
							pcall(function()
								c:Disconnect()
							end)
						end
					end
				end
				anti_idle = Idled:Connect(function()
					service.VirtualInputManager:SendMouseWheelEvent(service.UserInputService:GetMouseLocation().X, service.UserInputService:GetMouseLocation().Y, true, game)
				end)
			end)
		end
		t_start = os.clock()
		local ok, err = xpcall(save_game, function(err)
			return debug.traceback(err)
		end)
		if SafeMode then
			service.GuiService:ClearError()
			service.RunService:Set3dRenderingEnabled(true)
		end
		if oldGetHP then
			getHP = oldGetHP
		end
		if anti_idle then
			anti_idle:Disconnect()
		end
		if Connections then
			for _, connection in Connections do
				connection:Disconnect()
			end
		end
		GLOBAL_ENV[fname] = nil
		if statTxt then
			task.spawn(function()
				t_start = os.clock() - t_start
				local Log10 = math.log10(t_start)
				local ExtraTime = 10
				if ok then
					statTxt.Text = string.format("Saved! Time %.3f seconds; Size %s", t_start, get_size_format())
					statTxt.TextColor3 = Color3.new(0, 1)
					task.wait(Log10 * 2 + ExtraTime)
				else
					if Loading then
						task.cancel(Loading)
						Loading = nil
					end
					statTxt.Text = "Failed! Check F9 console for more info"
					statTxt.TextColor3 = Color3.new(1)
					warn("Error found while saving:")
					warn(err)
					task.wait(Log10 + ExtraTime)
				end
				statTxt:Destroy()
			end)
		end
		if OPTS.ShutdownWhenDone and ok then
			game:Shutdown()
		end
	end
end
return synsaveinstance
